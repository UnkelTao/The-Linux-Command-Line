\section{符号链接} % (fold)
\label{sec:符号链接}

在我们到处查看时，我们可能会看到一个目录，列出像这样的一条信息：
\begin{lstlisting}
lrwxrwxrwx 1 root root 11 2007-08-11 07:34 libc.so.6 -> libc-2.6.so 
\end{lstlisting}

\par 注意，这条信息第一个字符是``1''，并且看起来像有两个文件名？ 这是一个特殊文件，叫做符号链接（也称为软链接或者 symlink）。 在大多数类似 Unix 系统中，有可能一个文件被多个文件名参考。虽然这种特性的意义并不明显，但它真地很有用。

\par 描绘一下这样的情景：一个程序要求使用某个包含在名为``foo''文件中的共享资源，但是``foo''经常改变版本号。 这样，在文件名中包含版本号，会是一个好主意，因此管理员或者其它相关方，会知道安装了哪个``foo''版本。 这又会导致一个问题。如果我们更改了共享资源的名字，那么我们必须跟踪每个可能使用了 这个共享资源的程序，当每次这个资源的新版本被安装后，都要让使用了它的程序去寻找新的资源名。 这听起来很没趣。

\par 这就是符号链接存在至今的原因。比方说，我们安装了文件``foo'' 的 2.6 版本，它的 文件名是 ``foo-2.6''，然后创建了叫做``foo'' 的符号链接，这个符号链接指向 ``foo-2.6''。 这意味着，当一个程序打开文件 ``foo''时，它实际上是打开文件 ``foo-2.6''。 现在，每个人都很高兴。依赖于``foo''文件的程序能找到这个文件，并且我们能知道安装了哪个文件版本。 当升级到 ``foo-2.7'' 版本的时候，仅添加这个文件到文件系统中，删除符号链接 “foo”， 创建一个指向新版本的符号链接。这不仅解决了版本升级问题，而且还允许在系统中保存两个不同的文件版本。 假想 ``foo-2.7''有个错误（该死的开发者！）,那我们得回到原来的版本。 一样的操作，我们只需要删除指向新版本的符号链接，然后创建指向旧版本的符号链接就可以了。

\par 在上面列出的目录（来自于 Fedora 的 /lib 目录）展示了一个叫做 ``libc.so.6''的符号链接，这个符号链接指向一个 叫做 “libc-2.6.so” 的共享库文件。这意味着，寻找文件 ``libc.so.6''的程序，实际上得到是文件 ``libc-2.6.so''。 在下一章节，我们将学习如何建立符号链接。


% section 符号链接 (end)